{"version":3,"file":"local-echo.js","mappings":"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","sources":["webpack://local-echo/./node_modules/shell-quote/index.js","webpack://local-echo/./node_modules/shell-quote/parse.js","webpack://local-echo/./node_modules/shell-quote/quote.js","webpack://local-echo/webpack/bootstrap","webpack://local-echo/webpack/runtime/define property getters","webpack://local-echo/webpack/runtime/hasOwnProperty shorthand","webpack://local-echo/./lib/HistoryController.js","webpack://local-echo/./lib/Utils.js","webpack://local-echo/./index.js","webpack://local-echo/./lib/LocalEchoController.js"],"sourcesContent":["'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '\\\\<\\\\<\\\\<', '>>', '>\\\\&', '<\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (Math.pow(16, 8) * Math.random()).toString(16);\n}\n\nfunction parseInternal(s, env, opts) {\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n\t].join('|'), 'g');\n\tvar match = s.match(chunker).filter(Boolean);\n\n\tif (!match) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\tif (!opts) {\n\t\topts = {};\n\t}\n\n\tvar commented = false;\n\n\tfunction getVar(_, pre, key) {\n\t\tvar r = typeof env === 'function' ? env(key) : env[key];\n\t\tif (r === undefined && key != '') {\n\t\t\tr = '';\n\t\t} else if (r === undefined) {\n\t\t\tr = '$';\n\t\t}\n\n\t\tif (typeof r === 'object') {\n\t\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t\t}\n\t\treturn pre + r;\n\t}\n\n\treturn match.map(function (s, j) {\n\t\tif (commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (RegExp('^' + CONTROL + '$').test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar SQ = \"'\";\n\t\tvar DQ = '\"';\n\t\tvar DS = '$';\n\t\tvar BS = opts.escape || '\\\\';\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\t// debugger\n\t\t\tif (s.charAt(i) === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i - 2, 3));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.substr(i, varend - i);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(s.charAt(i))) {\n\t\t\t\tvarname = s.charAt(i);\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvarend = s.substr(i).match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = s.substr(i);\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = s.substr(i, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(null, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (RegExp('^' + CONTROL + '$').test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if ((/^#$/).test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, { comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t\t}\n\t\t\t\treturn [{ comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed aruments\n\t\tif (arg === undefined) {\n\t\t\treturn prev;\n\t\t}\n\t\treturn prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (RegExp('^' + TOKEN).test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","'use strict';\n\nmodule.exports = function quote(xs) {\n\treturn xs.map(function (s) {\n\t\tif (s && typeof s === 'object') {\n\t\t\treturn s.op.replace(/(.)/g, '\\\\$1');\n\t\t}\n\t\tif ((/[\"\\s]/).test(s) && !(/'/).test(s)) {\n\t\t\treturn \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n\t\t}\n\t\tif ((/[\"'\\s]/).test(s)) {\n\t\t\treturn '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t\t}\n\t\treturn String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@[\\\\\\]^`{|}])/g, '$1\\\\$2');\n\t}).join(' ');\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * The history controller provides an ring-buffer\n */\nexport class HistoryController {\n  constructor(size) {\n    this.size = size;\n    this.entries = [];\n    this.cursor = 0;\n  }\n\n  /**\n   * Push an entry and maintain ring buffer size\n   */\n  push(entry) {\n    // Skip empty entries\n    if (entry.trim() === \"\") return;\n    // Skip duplicate entries\n    const lastEntry = this.entries[this.entries.length - 1];\n    if (entry == lastEntry) return;\n    // Keep track of entries\n    this.entries.push(entry);\n    if (this.entries.length > this.size) {\n      this.entries.pop(0);\n    }\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Rewind history cursor on the last entry\n   */\n  rewind() {\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Returns the previous entry\n   */\n  getPrevious() {\n    const idx = Math.max(0, this.cursor - 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n\n  /**\n   * Returns the next entry\n   */\n  getNext() {\n    const idx = Math.min(this.entries.length, this.cursor + 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n}\n","import { parse } from \"shell-quote\";\n\n/**\n * Detects all the word boundaries on the given input\n */\nexport function wordBoundaries(input, leftSide = true) {\n  let match;\n  const words = [];\n  const rx = /\\w+/g;\n\n  while ((match = rx.exec(input))) {\n    if (leftSide) {\n      words.push(match.index);\n    } else {\n      words.push(match.index + match[0].length);\n    }\n  }\n\n  return words;\n}\n\n/**\n * The closest left (or right) word boundary of the given input at the\n * given offset.\n */\nexport function closestLeftBoundary(input, offset) {\n  const found = wordBoundaries(input, true)\n    .reverse()\n    .find(x => x < offset);\n  return found == null ? 0 : found;\n}\nexport function closestRightBoundary(input, offset) {\n  const found = wordBoundaries(input, false).find(x => x > offset);\n  return found == null ? input.length : found;\n}\n\n/**\n * Convert offset at the given input to col/row location\n *\n * This function is not optimized and practically emulates via brute-force\n * the navigation on the terminal, wrapping when they reach the column width.\n */\nexport function offsetToColRow(input, offset, maxCols) {\n  let row = 0,\n    col = 0;\n\n  for (let i = 0; i < offset; ++i) {\n    const chr = input.charAt(i);\n    if (chr == \"\\n\") {\n      col = 0;\n      row += 1;\n    } else {\n      col += 1;\n      if (col > maxCols) {\n        col = 0;\n        row += 1;\n      }\n    }\n  }\n\n  return { row, col };\n}\n\n/**\n * Counts the lines in the given input\n */\nexport function countLines(input, maxCols) {\n  return offsetToColRow(input, input.length, maxCols).row + 1;\n}\n\n/**\n * Checks if there is an incomplete input\n *\n * An incomplete input is considered:\n * - An input that contains unterminated single quotes\n * - An input that contains unterminated double quotes\n * - An input that ends with \"\\\"\n * - An input that has an incomplete boolean shell expression (&& and ||)\n * - An incomplete pipe expression (|)\n */\nexport function isIncompleteInput(input) {\n  // Empty input is not incomplete\n  if (input.trim() == \"\") {\n    return false;\n  }\n\n  // Check for dangling single-quote strings\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling double-quote strings\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling boolean or pipe operations\n  if (\n    input\n      .split(/(\\|\\||\\||&&)/g)\n      .pop()\n      .trim() == \"\"\n  ) {\n    return true;\n  }\n  // Check for tailing slash\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns true if the expression ends on a tailing whitespace\n */\nexport function hasTailingWhitespace(input) {\n  return input.match(/[^\\\\][ \\t]$/m) != null;\n}\n\n/**\n * Returns the last expression in the given input\n */\nexport function getLastToken(input) {\n  // Empty expressions\n  if (input.trim() === \"\") return \"\";\n  if (hasTailingWhitespace(input)) return \"\";\n\n  // Last token\n  const tokens = parse(input);\n  return tokens.pop() || \"\";\n}\n\n/**\n * Returns the auto-complete candidates for the given input\n */\nexport async function collectAutocompleteCandidates(callbacks, input) {\n  const tokens = parse(input);\n  let index = tokens.length - 1;\n  let expr = tokens[index] || \"\";\n\n  // Empty expressions\n  if (input.trim() === \"\") {\n    index = 0;\n    expr = \"\";\n  } else if (hasTailingWhitespace(input)) {\n    // Expressions with danging space\n    index += 1;\n    expr = \"\";\n  }\n\n  // Collect all auto-complete candidates from the callbacks\n  try {\n    const all = await callbacks.reduce((candidates, { fn, args }) => candidates.concat(fn(index, tokens, ...args)), []);\n    return all.filter(txt => txt.startsWith(expr));\n  } catch (e) {\n    console.error(\"Auto-complete error:\", e);\n    return candidates;\n  }\n  return [];\n  // Filter only the ones starting with the expression\n}\n\n\nexport function getSharedFragment(fragment, candidates) {\n\n  // end loop when fragment length = first candidate length\n  if (fragment.length >= candidates[0].length) return fragment;\n\n  // save old fragemnt\n  const oldFragment = fragment;\n\n  // get new fragment\n  fragment += candidates[0].slice(fragment.length, fragment.length+1);\n\n  for (let i=0; i<candidates.length; i++ ) {\n\n    // return null when there's a wrong candidate\n    if (!candidates[i].startsWith(oldFragment)) return null;\n\n    if (!candidates[i].startsWith(fragment)) {\n      return oldFragment;\n    }\n  }\n\n  return getSharedFragment(fragment, candidates);\n}\n","import LocalEchoController from \"./lib/LocalEchoController\";\nexport { HistoryController } from './lib/HistoryController';\n\nexport default LocalEchoController;\n","import { HistoryController } from \"./HistoryController\";\nimport {\n  closestLeftBoundary,\n  closestRightBoundary,\n  collectAutocompleteCandidates,\n  countLines,\n  getLastToken,\n  hasTailingWhitespace,\n  isIncompleteInput,\n  offsetToColRow,\n  getSharedFragment\n} from \"./Utils\";\n\n/**\n * A local terminal controller is responsible for displaying messages\n * and handling local echo for the terminal.\n *\n * Local echo supports most of bash-like input primitives. Namely:\n * - Arrow navigation on the input\n * - Alt-arrow for word-boundary navigation\n * - Alt-backspace for word-boundary deletion\n * - Multi-line input for incomplete commands\n * - Auto-complete hooks\n */\nexport default class LocalEchoController {\n  constructor(term = null, options = {}) {\n    this.term = term;\n    this._handleTermData = this.handleTermData.bind(this);\n    this._handleTermResize = this.handleTermResize.bind(this)\n\n    this.history = new HistoryController(options.historySize || 10);\n    this.maxAutocompleteEntries = options.maxAutocompleteEntries || 100;\n\n    this._autocompleteHandlers = [];\n    this._active = false;\n    this._input = \"\";\n    this._cursor = 0;\n    this._activePrompt = null;\n    this._activeCharPrompt = null;\n    this._termSize = {\n      cols: 0,\n      rows: 0,\n    };\n\n    this._disposables = [];\n\n    if (term) {\n      if (term.loadAddon) term.loadAddon(this);\n      else this.attach();\n    }\n  }\n\n  // xterm.js new plugin API:\n  activate(term) {\n    this.term = term;\n    this.attach();\n  }\n  dispose() {\n    this.detach();\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n  // User-Facing API\n  /////////////////////////////////////////////////////////////////////////////\n\n  /**\n   *  Detach the controller from the terminal\n   */\n  detach() {\n    if (this.term.off) {\n      this.term.off(\"data\", this._handleTermData);\n      this.term.off(\"resize\", this._handleTermResize);\n    } else {\n      this._disposables.forEach(d => d.dispose());\n      this._disposables = [];\n    }\n  }\n\n  /**\n   * Attach controller to the terminal, handling events\n   */\n  attach() {\n    if (this.term.on) {\n      this.term.on(\"data\", this._handleTermData);\n      this.term.on(\"resize\", this._handleTermResize);\n    } else {\n      this._disposables.push(this.term.onData(this._handleTermData));\n      this._disposables.push(this.term.onResize(this._handleTermResize));\n    }\n    this._termSize = {\n      cols: this.term.cols,\n      rows: this.term.rows,\n    };\n  }\n\n  /**\n   * Register a handler that will be called to satisfy auto-completion\n   */\n  addAutocompleteHandler(fn, ...args) {\n    this._autocompleteHandlers.push({\n      fn,\n      args\n    });\n  }\n\n  /**\n   * Remove a previously registered auto-complete handler\n   */\n  removeAutocompleteHandler(fn) {\n    const idx = this._autocompleteHandlers.findIndex(e => e.fn === fn);\n    if (idx === -1) return;\n\n    this._autocompleteHandlers.splice(idx, 1);\n  }\n\n  /**\n   * Return a promise that will resolve when the user has completed\n   * typing a single line\n   */\n  read(prompt, continuationPrompt = \"> \") {\n    return new Promise((resolve, reject) => {\n      this.term.write(prompt);\n      this._activePrompt = {\n        prompt,\n        continuationPrompt,\n        resolve,\n        reject\n      };\n\n      this._input = \"\";\n      this._cursor = 0;\n      this._active = true;\n    });\n  }\n\n  /**\n   * Return a promise that will be resolved when the user types a single\n   * character.\n   *\n   * This can be active in addition to `.read()` and will be resolved in\n   * priority before it.\n   */\n  readChar(prompt) {\n    return new Promise((resolve, reject) => {\n      this.term.write(prompt);\n      this._activeCharPrompt = {\n        prompt,\n        resolve,\n        reject\n      };\n    });\n  }\n\n  /**\n   * Abort a pending read operation\n   */\n  abortRead(reason = \"aborted\") {\n    if (this._activePrompt != null || this._activeCharPrompt != null) {\n      this.term.write(\"\\r\\n\");\n    }\n    if (this._activePrompt != null) {\n      this._activePrompt.reject(reason);\n      this._activePrompt = null;\n    }\n    if (this._activeCharPrompt != null) {\n      this._activeCharPrompt.reject(reason);\n      this._activeCharPrompt = null;\n    }\n    this._active = false;\n  }\n\n  /**\n   * Prints a message and changes line\n   */\n  println(message) {\n    this.print(message + \"\\n\");\n  }\n\n  /**\n   * Prints a message and properly handles new-lines\n   */\n  print(message) {\n    const normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\n    this.term.write(normInput.replace(/\\n/g, \"\\r\\n\"));\n  }\n\n  /**\n   * Prints a list of items using a wide-format\n   */\n  printWide(items, padding = 2) {\n    if (items.length == 0) return println(\"\");\n\n    // Compute item sizes and matrix row/cols\n    const itemWidth =\n      items.reduce((width, item) => Math.max(width, item.length), 0) + padding;\n    const wideCols = Math.floor(this._termSize.cols / itemWidth);\n    const wideRows = Math.ceil(items.length / wideCols);\n\n    // Print matrix\n    let i = 0;\n    for (let row = 0; row < wideRows; ++row) {\n      let rowStr = \"\";\n\n      // Prepare columns\n      for (let col = 0; col < wideCols; ++col) {\n        if (i < items.length) {\n          let item = items[i++];\n          item += \" \".repeat(itemWidth - item.length);\n          rowStr += item;\n        }\n      }\n      this.println(rowStr);\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Internal API\n  /////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Apply prompts to the given input\n   */\n  applyPrompts(input) {\n    const prompt = (this._activePrompt || {}).prompt || \"\";\n    const continuationPrompt =\n      (this._activePrompt || {}).continuationPrompt || \"\";\n\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\n  }\n\n  /**\n   * Advances the `offset` as required in order to accompany the prompt\n   * additions to the input.\n   */\n  applyPromptOffset(input, offset) {\n    const newInput = this.applyPrompts(input.substr(0, offset));\n    return newInput.length;\n  }\n\n  /**\n   * Clears the current prompt\n   *\n   * This function will erase all the lines that display the current prompt\n   * and move the cursor in the beginning of the first line of the prompt.\n   */\n  clearInput() {\n    const currentPrompt = this.applyPrompts(this._input);\n\n    // Get the overall number of lines to clear\n    const allRows = countLines(currentPrompt, this._termSize.cols);\n\n    // Get the line we are currently in\n    const promptCursor = this.applyPromptOffset(this._input, this._cursor);\n    const { col, row } = offsetToColRow(\n      currentPrompt,\n      promptCursor,\n      this._termSize.cols\n    );\n\n    // First move on the last line\n    const moveRows = allRows - row - 1;\n    for (var i = 0; i < moveRows; ++i) this.term.write(\"\\x1B[E\");\n\n    // Clear current input line(s)\n    this.term.write(\"\\r\\x1B[K\");\n    for (var i = 1; i < allRows; ++i) this.term.write(\"\\x1B[F\\x1B[K\");\n  }\n\n  /**\n   * Replace input with the new input given\n   *\n   * This function clears all the lines that the current input occupies and\n   * then replaces them with the new input.\n   */\n  setInput(newInput, clearInput = true) {\n    // Clear current input\n    if (clearInput) this.clearInput();\n\n    // Write the new input lines, including the current prompt\n    const newPrompt = this.applyPrompts(newInput);\n    this.print(newPrompt);\n\n    // Trim cursor overflow\n    if (this._cursor > newInput.length) {\n      this._cursor = newInput.length;\n    }\n\n    // Move the cursor to the appropriate row/col\n    const newCursor = this.applyPromptOffset(newInput, this._cursor);\n    const newLines = countLines(newPrompt, this._termSize.cols);\n    const { col, row } = offsetToColRow(\n      newPrompt,\n      newCursor,\n      this._termSize.cols\n    );\n    const moveUpRows = newLines - row - 1;\n\n    this.term.write(\"\\r\");\n    for (var i = 0; i < moveUpRows; ++i) this.term.write(\"\\x1B[F\");\n    for (var i = 0; i < col; ++i) this.term.write(\"\\x1B[C\");\n\n    // Replace input\n    this._input = newInput;\n  }\n\n  /**\n   * This function completes the current input, calls the given callback\n   * and then re-displays the prompt.\n   */\n  printAndRestartPrompt(callback) {\n    const cursor = this._cursor;\n\n    // Complete input\n    this.setCursor(this._input.length);\n    this.term.write(\"\\r\\n\");\n\n    // Prepare a function that will resume prompt\n    const resume = () => {\n      this._cursor = cursor;\n      this.setInput(this._input);\n    };\n\n    // Call the given callback to echo something, and if there is a promise\n    // returned, wait for the resolution before resuming prompt.\n    const ret = callback();\n    if (ret == null) {\n      resume();\n    } else {\n      ret.then(resume);\n    }\n  }\n\n  /**\n   * Set the new cursor position, as an offset on the input string\n   *\n   * This function:\n   * - Calculates the previous and current\n   */\n  setCursor(newCursor) {\n    if (newCursor < 0) newCursor = 0;\n    if (newCursor > this._input.length) newCursor = this._input.length;\n\n    // Apply prompt formatting to get the visual status of the display\n    const inputWithPrompt = this.applyPrompts(this._input);\n    const inputLines = countLines(inputWithPrompt, this._termSize.cols);\n\n    // Estimate previous cursor position\n    const prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);\n    const { col: prevCol, row: prevRow } = offsetToColRow(\n      inputWithPrompt,\n      prevPromptOffset,\n      this._termSize.cols\n    );\n\n    // Estimate next cursor position\n    const newPromptOffset = this.applyPromptOffset(this._input, newCursor);\n    const { col: newCol, row: newRow } = offsetToColRow(\n      inputWithPrompt,\n      newPromptOffset,\n      this._termSize.cols\n    );\n\n    // Adjust vertically\n    if (newRow > prevRow) {\n      for (let i = prevRow; i < newRow; ++i) this.term.write(\"\\x1B[B\");\n    } else {\n      for (let i = newRow; i < prevRow; ++i) this.term.write(\"\\x1B[A\");\n    }\n\n    // Adjust horizontally\n    if (newCol > prevCol) {\n      for (let i = prevCol; i < newCol; ++i) this.term.write(\"\\x1B[C\");\n    } else {\n      for (let i = newCol; i < prevCol; ++i) this.term.write(\"\\x1B[D\");\n    }\n\n    // Set new offset\n    this._cursor = newCursor;\n  }\n\n  /**\n   * Move cursor at given direction\n   */\n  handleCursorMove(dir) {\n    if (dir > 0) {\n      const num = Math.min(dir, this._input.length - this._cursor);\n      this.setCursor(this._cursor + num);\n    } else if (dir < 0) {\n      const num = Math.max(dir, -this._cursor);\n      this.setCursor(this._cursor + num);\n    }\n  }\n\n  /**\n   * Erase a character at cursor location\n   */\n  handleCursorErase(backspace) {\n    const { _cursor, _input } = this;\n    if (backspace) {\n      if (_cursor <= 0) return;\n      const newInput = _input.substr(0, _cursor - 1) + _input.substr(_cursor);\n      this.clearInput();\n      this._cursor -= 1;\n      this.setInput(newInput, false);\n    } else {\n      const newInput = _input.substr(0, _cursor) + _input.substr(_cursor + 1);\n      this.setInput(newInput);\n    }\n  }\n\n  /**\n   * Insert character at cursor location\n   */\n  handleCursorInsert(data) {\n    const { _cursor, _input } = this;\n    const newInput = _input.substr(0, _cursor) + data + _input.substr(_cursor);\n    this._cursor += data.length;\n    this.setInput(newInput);\n  }\n\n  /**\n   * Handle input completion\n   */\n  handleReadComplete() {\n    if (this.history) {\n      this.history.push(this._input);\n    }\n    if (this._activePrompt) {\n      this._activePrompt.resolve(this._input);\n      this._activePrompt = null;\n    }\n    this.term.write(\"\\r\\n\");\n    this._active = false;\n  }\n\n  /**\n   * Handle terminal resize\n   *\n   * This function clears the prompt using the previous configuration,\n   * updates the cached terminal size information and then re-renders the\n   * input. This leads (most of the times) into a better formatted input.\n   */\n  handleTermResize(data) {\n    const { rows, cols } = data;\n    this.clearInput();\n    this._termSize = { cols, rows };\n    this.setInput(this._input, false);\n  }\n\n  /**\n   * Handle terminal input\n   */\n  handleTermData(data) {\n    if (!this._active) return;\n\n    // If we have an active character prompt, satisfy it in priority\n    if (this._activeCharPrompt != null) {\n      this._activeCharPrompt.resolve(data);\n      this._activeCharPrompt = null;\n      this.term.write(\"\\r\\n\");\n      return;\n    }\n\n    // If this looks like a pasted input, expand it\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\n      const normData = data.replace(/[\\r\\n]+/g, \"\\r\");\n      Array.from(normData).forEach(c => this.handleData(c));\n    } else {\n      this.handleData(data);\n    }\n  }\n\n  /**\n   * Handle a single piece of information from the terminal.\n   */\n  async handleData(data) {\n    if (!this._active) return;\n    const ord = data.charCodeAt(0);\n    let ofs;\n\n    // Handle ANSI escape sequences\n    if (ord == 0x1b) {\n      switch (data.substr(1)) {\n        case \"[A\": // Up arrow\n          if (this.history) {\n            let value = this.history.getPrevious();\n            if (value) {\n              this.setInput(value);\n              this.setCursor(value.length);\n            }\n          }\n          break;\n\n        case \"[B\": // Down arrow\n          if (this.history) {\n            let value = this.history.getNext();\n            if (!value) value = \"\";\n            this.setInput(value);\n            this.setCursor(value.length);\n          }\n          break;\n\n        case \"[D\": // Left Arrow\n          this.handleCursorMove(-1);\n          break;\n\n        case \"[C\": // Right Arrow\n          this.handleCursorMove(1);\n          break;\n\n        case \"[3~\": // Delete\n          this.handleCursorErase(false);\n          break;\n\n        case \"[F\": // End\n          this.setCursor(this._input.length);\n          break;\n\n        case \"[H\": // Home\n          this.setCursor(0);\n          break;\n\n        case \"b\": // ALT + LEFT\n          ofs = closestLeftBoundary(this._input, this._cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"f\": // ALT + RIGHT\n          ofs = closestRightBoundary(this._input, this._cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"\\x7F\": // CTRL + BACKSPACE\n          ofs = closestLeftBoundary(this._input, this._cursor);\n          if (ofs != null) {\n            this.setInput(\n              this._input.substr(0, ofs) + this._input.substr(this._cursor)\n            );\n            this.setCursor(ofs);\n          }\n          break;\n      }\n\n      // Handle special characters\n    } else if (ord < 32 || ord === 0x7f) {\n      switch (data) {\n        case \"\\r\": // ENTER\n          if (isIncompleteInput(this._input)) {\n            this.handleCursorInsert(\"\\n\");\n          } else {\n            this.handleReadComplete();\n          }\n          break;\n\n        case \"\\x7F\": // BACKSPACE\n          this.handleCursorErase(true);\n          break;\n\n        case \"\\t\": // TAB\n          if (this._autocompleteHandlers.length > 0) {\n            const inputFragment = this._input.substr(0, this._cursor);\n            const hasTailingSpace = hasTailingWhitespace(inputFragment);\n            const candidates = await collectAutocompleteCandidates(\n              this._autocompleteHandlers,\n              inputFragment\n            );\n\n            // Sort candidates\n            candidates.sort();\n\n            // Depending on the number of candidates, we are handing them in\n            // a different way.\n            if (candidates.length === 0) {\n              // No candidates? Just add a space if there is none already\n              if (!hasTailingSpace) {\n                this.handleCursorInsert(\" \");\n              }\n            } else if (candidates.length === 1) {\n              // Just a single candidate? Complete\n              const lastToken = getLastToken(inputFragment);\n              this.handleCursorInsert(\n                candidates[0].substr(lastToken.length) + \" \"\n              );\n            } else if (candidates.length <= this.maxAutocompleteEntries) {\n\n              // search for a shared fragement\n              const sameFragment = getSharedFragment(inputFragment, candidates);\n\n              // if there's a shared fragement between the candidates\n              // print complete the shared fragment\n              if (sameFragment) {\n                const lastToken = getLastToken(inputFragment);\n                this.handleCursorInsert(\n                  sameFragment.substr(lastToken.length)\n                );\n              }\n\n              // If we are less than maximum auto-complete candidates, print\n              // them to the user and re-start prompt\n              this.printAndRestartPrompt(() => {\n                this.printWide(candidates);\n              });\n            } else {\n              // If we have more than maximum auto-complete candidates, print\n              // them only if the user acknowledges a warning\n              this.printAndRestartPrompt(() =>\n                this.readChar(\n                  `Display all ${candidates.length} possibilities? (y or n)`\n                ).then(yn => {\n                  if (yn == \"y\" || yn == \"Y\") {\n                    this.printWide(candidates);\n                  }\n                })\n              );\n            }\n          } else {\n            this.handleCursorInsert(\"    \");\n          }\n          break;\n\n        case \"\\x03\": // CTRL+C\n          this.setCursor(this._input.length);\n          this.term.write(\"^C\\r\\n\" + ((this._activePrompt || {}).prompt || \"\"));\n          this._input = \"\";\n          this._cursor = 0;\n          if (this.history) this.history.rewind();\n          break;\n      }\n\n      // Handle visible characters\n    } else {\n      this.handleCursorInsert(data);\n    }\n  }\n}\n"],"names":["exports","parse","CONTROL","join","META","BAREWORD","SINGLE_QUOTE","DOUBLE_QUOTE","TOKEN","i","Math","pow","random","toString","module","s","env","opts","mapped","chunker","RegExp","match","filter","Boolean","commented","map","j","test","op","BS","escape","quote","esc","out","isGlob","length","c","charAt","parseEnvVar","comment","slice","pattern","varend","varname","key","r","Error","substr","indexOf","index","undefined","JSON","stringify","reduce","prev","arg","concat","parseInternal","acc","xs","split","x","replace","String","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","HistoryController","constructor","size","this","entries","cursor","push","entry","trim","pop","rewind","getPrevious","idx","max","getNext","min","wordBoundaries","input","leftSide","words","rx","exec","closestLeftBoundary","offset","found","reverse","find","offsetToColRow","maxCols","row","col","countLines","hasTailingWhitespace","getLastToken","async","collectAutocompleteCandidates","callbacks","tokens","expr","candidates","fn","args","txt","startsWith","e","console","error","getSharedFragment","fragment","oldFragment","term","options","_handleTermData","handleTermData","bind","_handleTermResize","handleTermResize","history","historySize","maxAutocompleteEntries","_autocompleteHandlers","_active","_input","_cursor","_activePrompt","_activeCharPrompt","_termSize","cols","rows","_disposables","loadAddon","attach","activate","dispose","detach","off","forEach","on","onData","onResize","addAutocompleteHandler","removeAutocompleteHandler","findIndex","splice","read","prompt","continuationPrompt","Promise","resolve","reject","write","readChar","abortRead","reason","println","message","print","normInput","printWide","items","padding","itemWidth","width","item","wideCols","floor","wideRows","ceil","rowStr","repeat","applyPrompts","applyPromptOffset","clearInput","currentPrompt","allRows","promptCursor","moveRows","setInput","newInput","newPrompt","newCursor","newLines","moveUpRows","printAndRestartPrompt","callback","setCursor","resume","ret","then","inputWithPrompt","prevPromptOffset","prevCol","prevRow","newPromptOffset","newCol","newRow","handleCursorMove","dir","num","handleCursorErase","backspace","handleCursorInsert","data","handleReadComplete","charCodeAt","normData","Array","from","handleData","ord","ofs","value","closestRightBoundary","endsWith","inputFragment","hasTailingSpace","sort","lastToken","sameFragment","yn"],"sourceRoot":""}